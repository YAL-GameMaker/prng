<!DOCTYPE HTML><html lang="en"><head>
<meta charset="UTF-8">
<title>PRNG cheat sheet</title>
<meta name="viewport" content="width=device-width" />
<meta name="livenode" content="#doc" />
<meta property="theme-color" content="#FFF037" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_us" />
<meta property="og:site_name" content="YellowAfterlife" />
<meta property="og:title" content="PRNG cheat sheet" />
<script type="text/javascript">
if (document.location.host == "yal.cc" && location.protocol == "http:") {
	document.location.protocol = "https:";
}
</script>
<style type="text/css">body, #doc tt, #doc code {
	font: 15px 'Open Sans', sans-serif;
	line-height: 1.35;
}
body {
	margin: 0;
}
.main {
	width: 100%;
	min-height: 100%;
	min-height: 100vh;
	background-color: #f5f7f9;
}
.page {
	max-width: 656px;
	background: #ffffff;
	margin: 0 auto;
	padding: 8px;
	min-height: 100%;
	min-height: 100vh;
	box-sizing: border-box;
}
.page, .navmenu {
	box-shadow: 0 0 8px rgba(0, 0, 0, 0.1);
}
.page > p:first-child {
	margin-top: 0;
}
#doc, #doc ul, #doc ol {
	padding-left: 0;
	margin: 0;
}
#doc blockquote { margin: 0.5em 0; padding: 0; }
#doc article > ul, #doc li > ul,
#doc article > ol, #doc li > ol {
	padding-left: 20px;
}
#doc article ul li {
	list-style: disc;
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px"/></svg>'); 
}

#doc header {
	margin: 0;
	font-weight: 700;
	font-size: 100%;
	color: #458;
	border-left: 2px solid #f3f3f3;/* #f9f9f9*/
	padding-left: 4px;
	padding-top: 1px;
	padding-bottom: 1px;
	cursor: pointer;
	display: flex;
	align-items: center;
}
#doc header a {
	outline: none;
	text-decoration: none;
	color: #458;
	word-break: break-word;
}
#doc header::before {
	display: inline-block;
	content: "+";
	font: 12px monospace;
	border: 1px solid #458;
	line-height: 11px;
	height: 11px;
	width: 11px;
	text-align: center;
	border-radius: 50%;
	margin-right: 4px;
	vertical-align: middle;
	flex-shrink: 0;
}
#doc section.open > header::before {
	content: "-";
}
#doc section.empty > header::before {
	content: " "; /*"Â·"*/
}

#doc header:hover,
#doc .sticky-side:hover {
	border-left-color: #E7E7E7; /* rgba(0, 0, 0, 0.05) */
	background: rgba(0, 0, 0, 0.048);
}
#doc header .ret-arrow {
	font-weight: normal;
	margin: 0 0.1em;
}

#doc a.broken {
	color: red;
}
#doc p, .intro p {
	margin: 0;
}
#doc p + p, .intro p + p, #doc p.pad, .display-controls {
	margin-top: 0.5em;
}
#doc img {
	max-width: 100%;
}
#doc h3 {
	margin: 0.25em 0;
	font-size: 125%;
	font-weight: normal;
	border-bottom: 1px solid #ccc;
}

#doc article,
#doc ul,
#doc ol,
#doc blockquote {
	padding-left: 20px;
	border-left: 2px solid #f3f3f3;
}
#doc article {
	padding-top: 0.25em;
	padding-bottom: 0.5em;
	position: relative;
}
#doc .sticky-side {
	position: absolute;
	left: -2px;
	top: 0;
	bottom: 1px;
	width: 20px;
	writing-mode: vertical-rl;
	font-size: 85%;
	text-orientation: sideways;
	/*transform: rotate(0.05deg);*/
}
#doc .sticky-side,
#doc .sticky-side:visited {
	color: rgba(0, 0, 0, 0.3);
}
#doc .sticky-side > span {
	display: inline-block;
	position: sticky;
	left: 0;
	top: 0;
	padding: 0.3em 0;
	max-height: 100%;
	box-sizing: border-box;
	overflow: hidden;
	white-space: nowrap;
}
#doc tt {
	font-weight: bold;
}
#doc code {
	display: inline-block;
	background: #FFFBE4;
	font-family: Consolas, Ubuntu Mono, Dejavu Sans Mono, Lucida Console, monospace;
	font-weight: normal;
	font-size: 12px;
	line-height: 16px;
	padding: 0 2px;
	border: 1px solid #E6E0C4;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	max-width: 100%;
	word-break: break-word;
}

#doc table {
	border-spacing: 0;
	color: currentColor;
}
#doc table, #doc table td, #doc table th {
	border: 1px solid #f3f3f3;
}
#doc table td, #doc table th {
	padding: 0.1em 0.5em;
}
#doc pre {
	font-family: Consolas, Dejavu Sans Mono, Segoe UI Mono, Ubuntu Mono, Lucida Console, monospace;
	font-size: 9pt;
	line-height: 1.25;
	background: white;
	padding: 4px 2px 4px 10px;
	margin: 0;
	-moz-tab-size: 4;
	tab-size: 4;
	overflow-x: auto;
	white-space: pre-wrap;
	word-break: break-all;
}
#doc pre a {
	text-decoration: none;
}
#doc pre a:hover {
	text-decoration: underline;
}
#doc abbr[title] {
	text-decoration: underline;
	-webkit-text-decoration-color: #bbb;
	text-decoration-color: #bbb;
	-webkit-text-decoration-style: double;
	text-decoration-style: double;
}
#doc hr {
	margin: 0.5em 0;
	margin-right: 1em;
	border: 0;
	border-top: 2px dashed #f3f3f3;
}
#doc section + hr {
	margin: 0;
	height: 1em;
	border: 1px solid #f3f3f3;
	border-width: 1px 0 1px 0;
}
#doc section {
	border-top: 1px solid #f3f3f3;
	margin-top: 0.3em;
}
#doc section:first-child {
	margin-top: 0em;
}
#doc section:last-child {
	border-bottom: 1px solid #f3f3f3;
}
#doc section + section, #doc hr + section {
	border-top: 0;
	margin-top: 0;
}
#doc section + p {
	border-top: 1px solid #f3f3f3;
	padding-top: 0.3em;
}
/* delay display until load */
#doc[ready] section:not(.open) > article {
	display: none;
}</style>
<style type="text/css" id="lang_gml">/* GameMakerLanguage */
pre.gmlmd .md { color: #7A81A9 } /* #define */
pre.gmlmd .kw { color: #008; font-weight: bold } /* keyword */
pre.gmlmd .co { color: #080 } /* comment */
pre.gmlmd .nu { color: #F03232 } /* number */
pre.gmlmd .nx { color: #00f } /* hex */
pre.gmlmd .st { color: #00f } /* string */
pre.gmlmd .ts { color: #00f } /* template string */
pre.gmlmd .op { color: #000 } /* operator */
pre.gmlmd .cb { color: #008; font-weight: bold } /* curly brace */
pre.gmlmd .sv { color: #800 } /* std func */
pre.gmlmd .sf { color: #800 } /* std var */
pre.gmlmd .ri { color: #0078aa } /* assets */
pre.gmlmd .uf { color: #808 } /* user func */
pre.gmlmd .uv { color: #000 } /* user var */
pre.gmlmd .lv { color: #648 } /* local var */
pre.gmlmd .fd { color: #804 } /* field */

pre.gmlmd a.uf {
	background-color: #f7f0ff;
}
pre.gmlmd a.kw {
	background-color: #f0f7ff;
}
pre.gmlmd a.sf, #doc pre a.sv {
	background-color: #fff3f0;
}

#night:checked + .main pre.gmlmd .op { color: #CCCCCC }
#night:checked + .main pre.gmlmd .co { color: #5B995B }
#night:checked + .main pre.gmlmd .kw { color: #FFB871 }
#night:checked + .main pre.gmlmd .md { color: #FFB871 }
#night:checked + .main pre.gmlmd .cb { color: #FFB871 }
#night:checked + .main pre.gmlmd .sf { color: #FFB871 }
#night:checked + .main pre.gmlmd .uf { color: #FFB871 }
#night:checked + .main pre.gmlmd .nu { color: #FF8080 }
#night:checked + .main pre.gmlmd .st { color: #FCF320 }
#night:checked + .main pre.gmlmd .ts { color: #FF8080 }
#night:checked + .main pre.gmlmd .sv { color: #FF8080 }
#night:checked + .main pre.gmlmd .gv { color: #FF80FF }
#night:checked + .main pre.gmlmd .ri { color: #FF8080 }
#night:checked + .main pre.gmlmd .lv { color: #FFF899 }
#night:checked + .main pre.gmlmd .uv { color: #B2B1FF }
#night:checked + .main pre.gmlmd .fd { color: #B2B1FF }

#night:checked + .main pre.gmlmd a.uf,
#night:checked + .main pre.gmlmd a.kw,
#night:checked + .main pre.gmlmd a.sf {
	background-color: #431;
}
#night:checked + .main pre.gmlmd a.sv {
	background-color: #422;
}</style>
<style type="text/css" id="nav_menu">.main {
	display: flex;
	flex-direction: row-reverse;
	height: 100%;
	height: 100vh;
}
.main-center {
	flex-grow: 1;
	height: 100%;
	height: 100vh;
	overflow: auto;
}
.navmenu {
	width: 250px;
	height: 100%;
	height: 100vh;
	box-sizing: border-box;
	overflow-x: hidden;
	overflow-y: auto;
	resize: horizontal;
	margin-right: 10px;
	
	word-break: break-word;
	text-overflow: ellipsis;
	white-space: nowrap;
	
	background: white;
	border: 0.3em solid white;
}
.navmenu ul {
	margin: 0;
	padding-left: 1.5em;
}
.navmenu a {
	overflow: hidden;
}
@media (max-width: 760px) {
	.navmenu {
		display: none;
	}
}</style>
<meta name="livenode2" content=".main > nav" />
<style type="text/css" id="night_css">.main label[for="night"] {
	cursor: pointer;
}
#night { display: none }
#night:checked + .main {
	background-color: #424242;
}
#night:checked + .main .page,
#night:checked + .main .navmenu {
	background-color: #1c1c1c;
	border-color: #1c1c1c;
	box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
	color: white;
}
#night:checked + .main a,
#night:checked + .main a:visited,
#night:checked + .main #doc header,
#night:checked + .main label[for="night"] {
	color: #9DEC76;
}
#night:checked + .main #doc header:before,
#night:checked + .main #doc h3 {
	border-color: #9DEC76
}
#night:checked + .main #doc header,
#night:checked + .main #doc header:hover,
#night:checked + .main #doc .sticky-side:hover,
#night:checked + .main #doc article,
#night:checked + .main #doc section,
#night:checked + .main #doc section + p,
#night:checked + .main #doc hr,
#night:checked + .main #doc ul,
#night:checked + .main #doc ol,
#night:checked + .main #doc table,
#night:checked + .main #doc table td,
#night:checked + .main #doc table th
{
	border-color: rgba(205,225,255,0.1);
}
#night:checked + .main #doc header:hover,
#night:checked + .main #doc .sticky-side:hover,
#night:checked + .main #doc .asset:hover {
	background: rgba(205,225,255,0.1);
}
#night:checked + .main article ul li {
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px" fill="white"/></svg>'); 
}
#night:checked + .main pre {
	color: #cccccc;
	background: #000000;
	border: 1px solid #3E4757;
}
#night:checked + .main #doc code {
	background-color: #000;
	border-color: #5b7c9f;
	color: white;
}
#night:checked + .main #doc .sticky-side,
#night:checked + .main #doc .sticky-side:visited {
	color: rgba(255, 255, 255, 0.3);
}</style>
<style type="text/css" id="print_css">@media print {
	.main { background-color: transparent }
	.display-controls { display: none; }
	.page { width: 100%; box-shadow: none; }
	#doc header::before,
	#doc section.open header::before	{
		content: "~";
	}
	#doc { display: inherit }
	#doc section:not(.open) > article,
	#doc[ready] section:not(.open) > article {
		display: inherit;
	}
}</style>
<noscript><style>#doc header::before {
	content: "~";
}
#doc header:hover {
	border-left-color: #f3f3f3;
	background: inherit;
}
#doc { display: inherit }
#doc section:not(.open) > article {
	display: inherit;
}</style></noscript>
</head><body>
<input type="checkbox" id="night" checked/>
<div class="main ">
<script type="text/javascript">(function() {
	var night = document.getElementById("night");
	var path = "docmd night mode";
	var ls = window.localStorage;
	var dark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
	if (ls) {
		var item = ls.getItem(path);
		night.checked = item ? item == "true" : dark;
		night.onchange = function(_) {
			ls.setItem(path, "" + night.checked);
		};
	} else night.checked = dark;
})();</script>
<div class="main-center">
<main class="page">
<section class="intro">
<p>This is a "cheat sheet" for the "PRNG" extension by YellowAfterlife.
</p><p>
The extension can be found on <a href="https://yellowafterlife.itch.io/gamemaker-PRNG">itch.io</a>.
</p><p>
Check out <a href="https://yal.cc/gamemaker-custom-prngs">the blog post</a> for the big write-up!</p>
</section>
<section class="display-controls">
Click on sections to expand/collapse them.<br>Quick display controls:
<a href="javascript:void(0)" onclick="opt_none(); return false">Categories</a>
&middot; <a href="javascript:void(0)" onclick="opt_list(); return false">Sections</a>
&middot; <a href="javascript:void(0)" onclick="opt_all(); return false">Everything</a>
&middot; <a href="javascript:void(0)"><label for="night">Toggle night mode</label></a><br/>
</section><section id="doc">
<!--<doc--><p><p>

<style>
.main { background-color: #899FC6 }
.page, .navmenu { box-shadow: 0 0 8px rgba(0, 0, 0, 0.3) }
#night:checked + .main { background-color: #405070 }
#night:checked + .main .page { background-color: #1A202D }
</style>








</p><section><header id="Structure"><a href="#Structure" title="(permalink)">Structure</a></header><article><ul>
	<li><p>	Constructor-based RNGs are used like this:
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">rng</span> <span class="op">=</span> <span class="kw">new</span> <span class="uf">MINSTD</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="lv">rng</span><span class="op">.</span><span class="sf">setSeed</span><span class="op">(</span><span class="nu">1234</span><span class="op">)</span><span class="op">;</span> <span class="co">// don't forget!</span>
<span class="kw">var</span> <span class="lv">num</span> <span class="op">=</span> <span class="lv">rng</span><span class="op">.</span><span class="sf">intRange</span><span class="op">(</span><span class="nu">1</span><span class="op">,</span> <span class="nu">6</span><span class="op">)</span><span class="op">;</span>
</pre></li><li><p>	Array-based RNGs are used like this:
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">rng</span> <span class="op">=</span> <span class="sf">minstd_create</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="sf">minstd_set_seed</span><span class="op">(</span><span class="lv">rng</span><span class="op">,</span> <span class="nu">1234</span><span class="op">)</span><span class="op">;</span> <span class="co">// don't forget!</span>
<span class="kw">var</span> <span class="lv">num</span> <span class="op">=</span> <span class="sf">minstd_int_range</span><span class="op">(</span><span class="lv">rng</span><span class="op">,</span> <span class="nu">1</span><span class="op">,</span> <span class="nu">6</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		The same as constructors, but with underscores and in <code>snake_case</code>.
	</p></li><li><p>	Global-state RNGs are used like this:
		</p><pre class="gmlmd">
<span class="sf">minstd_set_seed</span><span class="op">(</span><span class="nu">1234</span><span class="op">)</span><span class="op">;</span> <span class="co">// don't forget!</span>
<span class="kw">var</span> <span class="lv">num</span> <span class="op">=</span> <span class="sf">minstd_int_range</span><span class="op">(</span><span class="nu">1</span><span class="op">,</span> <span class="nu">6</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		The same as arrays, but you don't pass an RNG struct/array to the functions.
	</p></li><li><p>	Macro-based RNGs are used like this:
		</p><pre class="gmlmd">
<a class="sf" href="#m_minstd_start">m_minstd_start</a><span class="op">(</span><span class="nu">1234</span><span class="op">)</span><span class="op">;</span>
<a class="sv" href="#m_minstd_next">m_minstd_next</a><span class="op">;</span>
<span class="kw">var</span> <span class="lv">num</span> <span class="op">=</span> <span class="nu">1</span> <span class="op">+</span> <span class="sf">floor</span><span class="op">(</span><a class="sf" href="#m_minstd_float">m_minstd_float</a><span class="op">(</span><span class="nu">6</span><span class="op">)</span><span class="op">)</span><span class="op">;</span>
<span class="uv">state</span> <span class="op">=</span> <a class="sv" href="#m_minstd_var">m_minstd_var</a><span class="op">;</span>
</pre></li></ul></article></section><section><header id="RNG"><a href="#RNG" title="(permalink)">Functions</a></header><article><a class="sticky-side" href="#RNG" title="Functions"><span>Functions</span></a><p>
	Each RNG has the following functions:
	</p><section><header id="RNG.new"><a href="#RNG.new" title="(permalink)">new</a></header><article><p>
		Constructor-based generators can be constructed without arguments, like this:
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">rng</span> <span class="op">=</span> <span class="kw">new</span> <span class="uf">MINSTD</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="lv">rng</span><span class="op">.</span><span class="sf">setSeed</span><span class="op">(</span><span class="nu">1234</span><span class="op">)</span><span class="op">;</span>
<span class="kw">var</span> <span class="lv">result</span> <span class="op">=</span> <span class="lv">rng</span><span class="op">.</span><span class="sf">intRange</span><span class="op">(</span><span class="nu">1</span><span class="op">,</span> <span class="nu">6</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		Don't forget to call <a href="#RNG.setSeed">setSeed</a> before you use the generator!
	</p></article></section><section><header id="RNG.destroy"><a href="#RNG.destroy" title="(permalink)">destroy()</a></header><article><p>
		The C++ extension has a destructor function for each generator
		that should be called to free up the associated memory on C++ side
		when you're done using the generator.
	</p></article></section><hr/><section><header id="RNG.next"><a href="#RNG.next" title="(permalink)">next()&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		Returns the next "raw" value from the generator.
		</p><p>
		The expected values are: </p><ul>
		<li>	Between 1 (<abbr title="inclusive">inc.</abbr>) and 2147483646 (<abbr title="inclusive">inc.</abbr>) for MINSTD
		</li><li>	Between 1 (<abbr title="inclusive">inc.</abbr>) and 2147483647 (<abbr title="inclusive">inc.</abbr>) for Rand0
		</li><li>	Any 64-bit integer except 0 for Xorshift64
		</li><li>	Between 0 (<abbr title="inclusive">inc.</abbr>) and 4294967295 (<abbr title="inclusive">inc.</abbr>) for WELL512.
		</li></ul></article></section><section><header id="RNG.setSeed"><a href="#RNG.setSeed" title="(permalink)">setSeed(seed)</a></header><article><p>
		<strong>Note:</strong> This is called <code>*_set_seed</code> in snake_case functions
		</p><p>
		Sets the random number generator seed.
		</p><p>
		Allowed value ranges vary by generator and are the same as in <a href="#RNG.next">next</a>.
		</p><p>
		For WELL512, you might also write your own function
		that initializes the state based on a larger input string/buffer.
	</p></article></section><section><header id="RNG.save"><a href="#RNG.save" title="(permalink)">save(buffer)</a></header><article><p>
		Writes the state of this RNG to a buffer (using <code>buffer_write</code>).
	</p></article></section><section><header id="RNG.load"><a href="#RNG.load" title="(permalink)">load(buffer)</a></header><article><p>
		Reads the state of this RNG from a buffer (using <code>buffer_read</code>).
	</p></article></section><hr/><section><header id="RNG.value"><a href="#RNG.value" title="(permalink)">value()&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		Returns a fractional random number between 0 and 1 (<abbr title="exclusive">ex.</abbr>).
		</p><p>
		Depending on the algorithm, 0 may be returned.
	</p></article></section><section><header id="RNG.float"><a href="#RNG.float" title="(permalink)">float(max)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		Returns a fractional random number between 0 and <code>max</code> (<abbr title="exclusive">ex.</abbr>).
		</p><p>
		Depending on the algorithm, 0 may be returned.
	</p></article></section><section><header id="RNG.floatRange"><a href="#RNG.floatRange" title="(permalink)">floatRange(min, max)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		<strong>Note:</strong> This is called <code>*_float_range</code> in snake_case functions
		</p><p>
		Returns a fractional random number between <code>min</code> and <code>max</code> (<abbr title="exclusive">ex.</abbr>).
		</p><p>
		Depending on the algorithm, <code>min</code> may be returned.
	</p></article></section><section><header id="RNG.int"><a href="#RNG.int" title="(permalink)">int(max)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		Returns an integer between 0 (<abbr title="inclusive">inc.</abbr>) and <code>max</code> (<abbr title="inclusive">inc.</abbr>).
		</p><p>
		Depending on the generator, the output can be either a <code>real</code> or an <code>int64</code>
		for performance reasons.
		</p><p>
		<strong>Note:</strong> if you need to use this function to generate values in a range larger than
		what the generator's <a href="#RNG.next">next</a> function can return,
		consider generating two smaller integers and combining them to avoid range/precision loss.
	</p></article></section><section><header id="RNG.intRange"><a href="#RNG.intRange" title="(permalink)">intRange(min, max)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		<strong>Note:</strong> This is called <code>*_int_range</code> in snake_case functions
		</p><p>
		Returns an integer between <code>min</code> (<abbr title="inclusive">inc.</abbr>) and <code>max</code> (<abbr title="inclusive">inc.</abbr>).
		</p><p>
		See above for generating integers in very large ranges.
	</p></article></section><p>
	WELL512 specifically also includes the following:
	</p><section><header id="RNG.intGM"><a href="#RNG.intGM" title="(permalink)">intGM(range)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		<strong>Note:</strong> This is called <code>*_int_gm</code> in snake_case functions
		</p><p>
		Returns an integer between 0 (<abbr title="inclusive">inc.</abbr>) and <code>max</code> (<abbr title="inclusive">inc.</abbr>).
		</p><p>
		This matches the way GameMaker's <code>irandom</code> function works
		(by stacking bits of two integers together).
	</p></article></section><section><header id="RNG.intRangeGM"><a href="#RNG.intRangeGM" title="(permalink)">intRangeGM(range)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		<strong>Note:</strong> This is called <code>*_int_range_gm</code> in snake_case functions
		</p><p>
		Returns an integer between <code>min</code> (<abbr title="inclusive">inc.</abbr>) and <code>max</code> (<abbr title="inclusive">inc.</abbr>).
		</p><p>
		This matches the way GameMaker's <code>irandom</code> function works
		(by stacking bits of two integers together).
	</p></article></section></article></section><section><header id="mRNG"><a href="#mRNG" title="(permalink)">Macros</a></header><article><a class="sticky-side" href="#mRNG" title="Macros"><span>Macros</span></a><p>
	Macro-based PRNG implementations have a smaller API
	because GM macros have limitations.
	</p><p>
	I'll use MINSTD as an example here.
	</p><section><header id="m_minstd_start"><a href="#m_minstd_start" title="(permalink)">m_minstd_start(state)</a></header><article><p>
		This declares a local variable for the PRNG macros and sets it to <code>state</code>.
	</p></article></section><section><header id="m_minstd_next"><a href="#m_minstd_next" title="(permalink)">m_minstd_next</a></header><article><p>
		This statement-macro advances the PRNG state.
		</p><p>
		This should be inserted before retrieving the result,
		or can be used alone to "skip" over states.
		</p><pre class="gmlmd">
<a class="sv" href="#m_minstd_next">m_minstd_next</a><span class="op">;</span>
</pre></article></section><section><header id="m_minstd_value"><a href="#m_minstd_value" title="(permalink)">m_minstd_value</a></header><article><p>
		This value-macro turns the output
		of the latest <a href="#m_minstd_next">next</a> block
		into a value in 0 .. 1 (<abbr title="exclusive">ex.</abbr>) range.
		</p><p>
		Depending on the algorithm, 0 may be included.
		</p><pre class="gmlmd">
<a class="sf" href="#m_minstd_start">m_minstd_start</a><span class="op">(</span><span class="uv">state</span><span class="op">)</span><span class="op">;</span>
<a class="sv" href="#m_minstd_next">m_minstd_next</a><span class="op">;</span>
<span class="uv">result</span> <span class="op">=</span> <a class="sv" href="#m_minstd_value">m_minstd_value</a><span class="op">;</span>
<span class="uv">state</span> <span class="op">=</span> <a class="sv" href="#m_minstd_var">m_minstd_var</a><span class="op">;</span>
</pre></article></section><section><header id="m_minstd_float"><a href="#m_minstd_float" title="(permalink)">m_minstd_float(max)</a></header><article><p>
		This ""function"" macro turns the output
		of the latest <a href="#m_minstd_next">next</a> block
		into a value in 0 .. <code>max</code> (<abbr title="exclusive">ex.</abbr>) range.
		</p><p>
		Depending on the algorithm, 0 may be included.
		</p><pre class="gmlmd">
<a class="sf" href="#m_minstd_start">m_minstd_start</a><span class="op">(</span><span class="uv">state</span><span class="op">)</span><span class="op">;</span>
<a class="sv" href="#m_minstd_next">m_minstd_next</a><span class="op">;</span>
<span class="uv">result</span> <span class="op">=</span> <a class="sf" href="#m_minstd_float">m_minstd_float</a><span class="op">(</span><span class="nu">10</span><span class="op">)</span><span class="op">;</span>
<span class="uv">state</span> <span class="op">=</span> <a class="sv" href="#m_minstd_var">m_minstd_var</a><span class="op">;</span>
</pre><p>
		<strong>Note:</strong> this is implemented as
		</p><pre class="gmlmd">
<span class="md">#macro</span> <a class="sv" href="#m_minstd_float">m_minstd_float</a> <a class="sv" href="#m_minstd_value">m_minstd_value</a> <span class="op">*</span>
</pre><p>
		so might want to wrap it in parentheses if you're doing complex operator combinations.
	</p></article></section><section><header id="m_minstd_var"><a href="#m_minstd_var" title="(permalink)">m_minstd_var</a></header><article><p>
		This value-macro holds the local variable made for the PRNG macros.
		</p><p>
		You can use it to access the state after you're done generating values
		and need to store it until the later use.
		</p><pre class="gmlmd">
<a class="sf" href="#m_minstd_start">m_minstd_start</a><span class="op">(</span><span class="uv">state</span><span class="op">)</span><span class="op">;</span>
<span class="co">// ... do some work</span>
<span class="uv">state</span> <span class="op">=</span> <a class="sv" href="#m_minstd_var">m_minstd_var</a><span class="op">;</span>
</pre></article></section></article></section><section><header id="other"><a href="#other" title="(permalink)">DIY functions</a></header><article><a class="sticky-side" href="#other" title="DIY functions"><span>DIY functions</span></a><p>
	I couldn't decide on whether I should include a bunch of identical functions in each generator
	so I'm going to tell you how these are supposed to work:
	</p><section><header id="choose"><a href="#choose" title="(permalink)">choose(...args)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		Single-instance:
		</p><pre class="gmlmd">
<span class="co">/// @param ...agrs</span>
<span class="kw">function</span> <a class="sf" href="#choose">choose</a><span class="op">(</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">return</span> <span class="sv">argument</span><span class="op">[</span><span class="uv">rng</span><span class="op">.</span><span class="sf">int</span><span class="op">(</span><span class="sv">argument_count</span> <span class="op">-</span> <span class="nu">1</span><span class="op">)</span><span class="op">]</span><span class="op">;</span>
<span class="cb">}</span>
</pre><p>
		Multi-instance:
		</p><pre class="gmlmd">
<span class="co">/// @param rng</span>
<span class="co">/// @param ...agrs</span>
<span class="kw">function</span> <a class="sf" href="#choose">choose</a><span class="op">(</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">return</span> <span class="sv">argument</span><span class="op">[</span><span class="nu">1</span> <span class="op">+</span> <span class="uv">rng</span><span class="op">.</span><span class="sf">int</span><span class="op">(</span><span class="sv">argument_count</span> <span class="op">-</span> <span class="nu">2</span><span class="op">)</span><span class="op">]</span><span class="op">;</span>
<span class="cb">}</span>
</pre></article></section><section><header id="choose_weighted"><a href="#choose_weighted" title="(permalink)">Weighted "choose"</a></header><article><p>
		I wrote <a href="https://yal.cc/gamemaker-weighted-choose/">a post</a> about this.
		</p><pre class="gmlmd">
<span class="co">/// @param ...chance_value_pairs</span>
<span class="kw">function</span> <a class="sf" href="#choose_weighted">choose_weighted</a><span class="op">(</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">var</span> <span class="lv">n</span> <span class="op">=</span> <span class="nu">0</span><span class="op">;</span>
    <span class="kw">for</span> <span class="op">(</span><span class="kw">var</span> <span class="lv">i</span> <span class="op">=</span> <span class="nu">1</span><span class="op">;</span> <span class="lv">i</span> <span class="op">&lt;</span> <span class="sv">argument_count</span><span class="op">;</span> <span class="lv">i</span> <span class="op">+=</span> <span class="nu">2</span><span class="op">)</span> <span class="cb">{</span>
        <span class="kw">if</span> <span class="op">(</span><span class="sv">argument</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span> <span class="op">&lt;=</span> <span class="nu">0</span><span class="op">)</span> <span class="kw">continue</span><span class="op">;</span>
        <span class="lv">n</span> <span class="op">+=</span> <span class="sv">argument</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span><span class="op">;</span>
    <span class="cb">}</span>
    
    <span class="lv">n</span> <span class="op">=</span> <span class="uv">rng</span><span class="op">.</span><span class="sf">float</span><span class="op">(</span><span class="lv">n</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">for</span> <span class="op">(</span><span class="kw">var</span> <span class="lv">i</span> <span class="op">=</span> <span class="nu">1</span><span class="op">;</span> <span class="lv">i</span> <span class="op">&lt;</span> <span class="sv">argument_count</span><span class="op">;</span> <span class="lv">i</span> <span class="op">+=</span> <span class="nu">2</span><span class="op">)</span> <span class="cb">{</span>
        <span class="kw">if</span> <span class="op">(</span><span class="sv">argument</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span> <span class="op">&lt;=</span> <span class="nu">0</span><span class="op">)</span> <span class="kw">continue</span><span class="op">;</span>
        <span class="lv">n</span> <span class="op">-=</span> <span class="sv">argument</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span><span class="op">;</span>
        <span class="kw">if</span> <span class="op">(</span><span class="lv">n</span> <span class="op">&lt;</span> <span class="nu">0</span><span class="op">)</span> <span class="kw">return</span> <span class="sv">argument</span><span class="op">[</span><span class="lv">i</span> <span class="op">-</span> <span class="nu">1</span><span class="op">]</span><span class="op">;</span>
    <span class="cb">}</span>
    
    <span class="kw">return</span> <span class="sv">argument</span><span class="op">[</span><span class="nu">0</span><span class="op">]</span><span class="op">;</span>
<span class="cb">}</span>
</pre></article></section><section><header id="randomize"><a href="#randomize" title="(permalink)">randomize()&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		GameMaker defines the function something like this:
		</p><pre class="gmlmd">
<span class="kw">global</span><span class="op">.</span><span class="gv">__time_start</span> <span class="op">=</span> <span class="sf">date_second_span</span><span class="op">(</span><span class="nu">25569</span><span class="op">,</span> <span class="sf">date_current_datetime</span><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span> <span class="nu">1000_000</span><span class="op">;</span>
<span class="kw">function</span> <a class="sf" href="#randomize">randomize</a><span class="op">(</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">var</span> <span class="lv">t</span> <span class="op">=</span> <span class="kw">global</span><span class="op">.</span><span class="gv">__time_start</span> <span class="op">+</span> <span class="sf">get_timer</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">var</span> <span class="lv">s</span> <span class="op">=</span> <span class="op">(</span><span class="op">(</span><span class="lv">t</span> <span class="op">&gt;&gt;</span> <span class="nu">32</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="lv">t</span> <span class="op">&amp;</span> <span class="nu">0xffff_ffff</span><span class="op">)</span><span class="op">)</span>
            <span class="op">^</span> <span class="op">(</span><span class="op">(</span><span class="lv">t</span> <span class="op">&gt;&gt;</span> <span class="nu">16</span><span class="op">)</span> <span class="op">&amp;</span> <span class="nu">0x0000_ffff</span><span class="op">)</span>
            <span class="op">^</span> <span class="op">(</span><span class="op">(</span><span class="lv">t</span> <span class="op">&lt;&lt;</span> <span class="nu">16</span><span class="op">)</span> <span class="op">&amp;</span> <span class="nu">0xffff_0000</span><span class="op">)</span><span class="op">;</span>
    <span class="uv">rng</span><span class="op">.</span><span class="sf">setSeed</span><span class="op">(</span><span class="lv">s</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">return</span> <span class="lv">s</span><span class="op">;</span>
<span class="cb">}</span>
</pre><p>
		(or
		<a href="https://github.com/YoYoGames/GameMaker-HTML5/blob/c009844c7f7f2e2897858ab02baf2eb0c513872c/scripts/functions/Function_Maths.js#L582-L584">this</a>
		in HTML5,
		<a href="https://github.com/YoYoGames/GameMaker-HTML5/issues/605">except that's wrong</a>
		at the time of writing)
		</p><p>
		This isn't 100% accurate for what happens on game [re-]start,
		but we don't get any other high-precision timing functions,
		so it is what it is.
	</p></article></section><section><header id="random_get_seed"><a href="#random_get_seed" title="(permalink)">random_get_seed()&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		<code>random_get_seed</code> returns the last seed that was passed to the RNG
		(either using <code>random_set_seed</code> or <code>randomize</code>),
		which is not very useful and was most commonly misused
		as people thought that doing
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">s</span> <span class="op">=</span> <a class="sf" href="#random_get_seed">random_get_seed</a><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="kw">var</span> <span class="lv">a</span> <span class="op">=</span> <span class="sf">random</span><span class="op">(</span><span class="nu">10</span><span class="op">)</span><span class="op">;</span>
<span class="sf">random_set_seed</span><span class="op">(</span><span class="lv">s</span><span class="op">)</span><span class="op">;</span>
<span class="kw">var</span> <span class="lv">b</span> <span class="op">=</span> <span class="sf">random</span><span class="op">(</span><span class="nu">10</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		would store/restore the PRNG state and match the value between <code>a</code> and <code>b</code>.
		</p><p>
		You would want <a href="#RNG.save">save</a> / <a href="#RNG.load">load</a> for that.
	</p></article></section></article></section><section><header id="etc"><a href="#etc" title="(permalink)">Rarer topics</a></header><article><a class="sticky-side" href="#etc" title="Rarer topics"><span>Rarer topics</span></a><section><header id="etc-mix"><a href="#etc-mix" title="(permalink)">Mixing generators</a></header><article><p>
		If you want to use both struct-based GML and struct-based C++ versions of the same RNG at once,
		rename one of the constructors.
		</p><p>
		If you want to use array-based and/or single-instance global <i>or</i> GML and C++ based versions
		of either at once, find-replace the RNG prefix (like <code>minstd_</code> for MINSTD) in the script.
		</p><p>
		I do not recommend trying to rename functions in the native extension unless you know what you're doing.
	</p></article></section><section><header id="etc-raw"><a href="#etc-raw" title="(permalink)">Using raw pointers</a></header><article><a class="sticky-side" href="#etc-raw" title="Using raw pointers"><span>Using raw pointers</span></a><p>
		Raw pointer API offers the most performance you can squeeze out of the C++ extension
		at cost of not performing any data validation.
		</p><p>
		That is, if you destroy a PRNG and then attempt to call a function on it,
		your game will most likely crash.
		</p><section><header>Obtaining pointers</header><article><p>
			If you are using a struct API, the pointer is stored in the <code>__ptr__</code> variable:
			</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">rng</span> <span class="op">=</span> <span class="kw">new</span> <span class="sf">WELL512</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="uv">rptr</span> <span class="op">=</span> <span class="lv">rng</span><span class="op">.</span><span class="fd">__ptr__</span><span class="op">;</span>
</pre><p>
			If you are using an array-based API, the pointer is stored in the second item of the array:
			</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">rng</span> <span class="op">=</span> <span class="sf">well512_create</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="uv">rptr</span> <span class="op">=</span> <span class="lv">rng</span><span class="op">[</span><span class="nu">1</span><span class="op">]</span><span class="op">;</span>
</pre></article></section><section><header>Using pointers</header><article><p>
			Raw pointer functions are named exactly like the array-based API functions
			but with a <code>_raw</code> suffix:
			</p><pre class="gmlmd">
<span class="sf">well512_set_seed_raw</span><span class="op">(</span><span class="uv">rptr</span><span class="op">,</span> <span class="nu">1234</span><span class="op">)</span><span class="op">;</span>
<span class="kw">var</span> <span class="lv">roll</span> <span class="op">=</span> <span class="sf">well512_int_range_raw</span><span class="op">(</span><span class="uv">rptr</span><span class="op">,</span> <span class="nu">1</span><span class="op">,</span> <span class="nu">6</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header>Saving/loading</header><article><p>
			Raw save/load functions take a buffer address and position
			so perhaps don't call these manually unless you really have to.
		</p></article></section></article></section></article></section></p><!--doc>-->
</section>
</div>
<!--<navmenu--><nav class="navmenu"><ul><li><a href="#Structure">Structure</a><ul></ul></li><li><a href="#RNG">Functions</a><ul><li><a href="#RNG.new">new</a><ul></ul></li><li><a href="#RNG.destroy">destroy()</a><ul></ul></li><li><a href="#RNG.next">next()&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#RNG.setSeed">setSeed(seed)</a><ul></ul></li><li><a href="#RNG.save">save(buffer)</a><ul></ul></li><li><a href="#RNG.load">load(buffer)</a><ul></ul></li><li><a href="#RNG.value">value()&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#RNG.float">float(max)&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#RNG.floatRange">floatRange(min, max)&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#RNG.int">int(max)&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#RNG.intRange">intRange(min, max)&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#RNG.intGM">intGM(range)&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#RNG.intRangeGM">intRangeGM(range)&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li></ul></li><li><a href="#mRNG">Macros</a><ul><li><a href="#m_minstd_start">m_minstd_start(state)</a><ul></ul></li><li><a href="#m_minstd_next">m_minstd_next</a><ul></ul></li><li><a href="#m_minstd_value">m_minstd_value</a><ul></ul></li><li><a href="#m_minstd_float">m_minstd_float(max)</a><ul></ul></li><li><a href="#m_minstd_var">m_minstd_var</a><ul></ul></li></ul></li><li><a href="#other">DIY functions</a><ul><li><a href="#choose">choose(...args)&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#choose_weighted">Weighted "choose"</a><ul></ul></li><li><a href="#randomize">randomize()&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li><li><a href="#random_get_seed">random_get_seed()&#8203;<span class="ret-arrow">&#10140;</span></a><ul></ul></li></ul></li><li><a href="#etc">Rarer topics</a><ul><li><a href="#etc-mix">Mixing generators</a><ul></ul></li><li><a href="#etc-raw">Using raw pointers</a><ul></ul></li></ul></li></ul></nav><!--navmenu>-->
</main></div>
<script type="text/javascript">(function() {
	var doc, headers;
	//
	var path = "PRNG cheat sheet";
	var state = null;
	if (window.localStorage && JSON.parse) {
		state = window.localStorage.getItem(path);
		state = state ? JSON.parse(state) : { };
		if (state == null) state = { };
	}
	var isLocal = (location.host.indexOf("localhost") == 0);
	//
	function h3bind(h3) {
		var node = h3.parentNode;
		var snip = node.children[1];
		var id = h3.id || h3.textContent;
		h3.snip = snip;
		h3.doc_set = function(z) {
			if (z) node.classList.add("open"); else node.classList.remove("open");
			if (state) {
				state[id] = z;
				window.localStorage.setItem(path, JSON.stringify(state));
			}
		}
		h3.doc_hide = function() {
			this.doc_set(false);
		}
		h3.doc_show = function() {
			this.doc_set(true);
		}
		h3.onclick = function(_) {
			var seen = !node.classList.contains("open");
			h3.doc_set(seen);
			return false;
		};
	}
	function getHashFunc(id) {
		var node = document.getElementById(id);
		if (node == null) return null;
		return function(e) {
			while (node && node != doc) {
				if (node.classList.contains("item")) {
					node.classList.add("open");
				}
				node = node.parentElement;
			}
		};
	}
	// Display helpers:
	window.opt_none = function() {
		for (var li = 0; li < headers.length; li++) headers[li].doc_hide();
	};
	window.opt_list = function() {
		for (var li = 0; li < headers.length; li++) {
			var h3 = headers[li];
			if (h3.parentNode.parentNode != doc) {
				h3.doc_hide();
			} else h3.doc_show();
		}
	};
	window.opt_all = function() {
		for (var li = 0; li < headers.length; li++) headers[li].doc_show();
	};
	window.live_post = function() {
		doc = document.getElementById("doc");
		headers = doc.getElementsByTagName("header");
		//
		for (var i = 0; i < headers.length; i++) h3bind(headers[i]);
		// Clicks in document expand the related section:
		var anchors = doc.getElementsByTagName("a");
		for (var i = 0; i < anchors.length; i++) {
			var anchor = anchors[i];
			if (anchor.classList.contains("header")) continue;
			var href = anchor.getAttribute("href");
			if (href[0] == "#") {
				var fn = getHashFunc(href.substr(1));
				if (!fn) {
					anchor.classList.add("broken");
					anchor.title = "(section missing)";
				} else anchor.addEventListener("click", fn);
			}
		}
		//
		for (var li = 0; li < headers.length; li++) {
			var h3 = headers[li];
			var val = state ? state[h3.id || h3.textContent] : null;
			if (val == null) val = isLocal || h3.parentNode.parentNode == doc;
			if (val) h3.doc_show(); else h3.doc_hide();
		}
	};
	window.live_post();
	//
	(function() {
		var hash = document.location.hash;
		if (hash) {
			var _hash = hash.substr(1);
			getHashFunc(_hash)();
			setTimeout(function() {
				document.location.hash = hash + " ";
				setTimeout(function() {
					document.location.hash = hash;
				}, 100);
			}, 100);
		}
	})();
	//
	doc.setAttribute("ready", "");
	})();</script>
</body></html>
